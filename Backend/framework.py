from flask import Flask, jsonify, session, request, send_file, send_from_directory
from flask_session import Session
from flask_cors import CORS

from werkzeug.utils import secure_filename

from utility.requestHandler import *
from utility.deleteTempFiles import *
from algEngine import *

import shutil

# Setup Flask app
app = Flask(__name__)
Session(app)
CORS(app, supports_credentials=True)
base_dir  = os.path.abspath(os.path.dirname(__file__))
app.config['UPLOAD_FOLDER'] = base_dir


# Set up algEngine and specify the database directory.
engine = algEngine(".\\references")


# Default test router.
# Users can test deployment by browser to view this url.
@app.route('/')
def hello_world():
    return 'Deployed.'


# Unified router for taking user upload.
# Able to handle github repo address as a string and zipped file, txt or any other single source file inside requset body.
# Two required keys: 
#   1. sessionID: Unique ID generated by the front end.
#   2. userUpload: where the address or file is included.
@app.route('/file_upload',methods=['POST'])
def upload():
    print('\n===================================================================================== \n')
    print('New API calling initiated.')
    if request.method=='CONNECT':
        return "Stop"
    if request.method == "POST":
        # Calling handle method inside requestHandler.py to distinguish the type of user upload
        data = handle(request.files.get('userUpload'), request.form.to_dict())

        # If it is not a github address, return error code 100.
        if data['type'] == 'string':
            if "https://github.com" not in data['content']:

                print('Terminated with error.')
                print('It is not a github repo address.')

                return jsonify({"code": 100, "msg": "Failed. It is not a github repo address."})

        # If userUpload is a zipped file, temproraly save it inside ./storage for further process
        # replace content as a path to the temp storage 
        elif data['type'] == 'application/zip':
            data['content'] = save(request.files.get('userUpload'), data['sessionID'])

        # If it is single file, store the content into ./storage for further process  
        # replace content as a path to the temp storage 
        elif data['type'] == 'application/octet-stream':
            local_dir = os.path.join(base_dir, 'storage')
            dir = os.path.join(local_dir, data['sessionID'])
            if not os.path.exists(dir):
                os.makedirs(dir) 
                with open(dir + "/temp.txt", 'wb') as f:
                    content = request.files.get('userUpload').read()
                    f.write(content)
                    f.close()
                data['content'] = dir

            else:
                print('Terminated with error.')
                print('SessionID has been token by earlier access.')
                return jsonify({"code": 202, "msg": "Failed. SessionID has been token by earlier access. "})

        # If it is single txt file, also store the content into ./storage for further process  
        # replace content as a path to the temp storage 
        elif data['type'] == 'text/plain':
            local_dir = os.path.join(base_dir, 'storage')
            dir = os.path.join(local_dir, data['sessionID'])
            if not os.path.exists(dir):
                os.makedirs(dir) 
                with open(dir + "/temp.txt", 'wb') as f:
                    content = request.files.get('userUpload').read()
                    f.write(content)
                    f.close()
                data['content'] = dir

            else:
                print('Terminated with error.')
                print('SessionID has been token by earlier access.')

                return jsonify({"code": 202, "msg": "Failed. SessionID has been token by earlier access. "})

        else:
            print('Terminated with error.')
            print('Wrong file type')

            return jsonify({"code": 123, "msg": "Wrong file type"})

        # Calling process method in requestHandler.py to process the request content. 
        lst = process(data, base_dir)

        # Generate a permenent txt file of detected libraries for the download function.
        generateTXT(lst, data['sessionID'])

        # Clear up all temp files
        deleteTempFiles(data['sessionID'])

        # Output to console
        print('Found ', end='')
        print(len(lst), end='')
        print(' libraries.')

    print('\n===================================================================================== \n')

    return jsonify(engine.process_upload(lst))


# Looking for the result in [sessionID].txt
# then return the file for the front end to download
@app.route('/download',methods=['GET'])
def download():
    data = request.data.decode()
    if "sessionID=" in data:
        sessionID = data.split("sessionID=")[1]
        if os.path.exists('txt\\' + sessionID + ".txt"):
            print('txt\\' + sessionID + ".txt")
            try: 
                print("success")
                return send_file('txt\\' + sessionID + ".txt", as_attachment = False)
            except:
                return jsonify({"code": 404, "msg": "Failed. No record found."})
    else:
        return jsonify({"code": 201, "msg": "No sessionID found"})


# Unzip and store the user uploaded zip file. 
def save(file, sessionID):
    if file:
        filename = secure_filename(file.filename)
        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))  # save zip

        local_dir = os.path.join(base_dir, 'storage')  
        dir = os.path.join(local_dir, sessionID)  # path for zip file

        temp = os.path.join(base_dir, filename)  # path for zip file
        shutil.unpack_archive(filename=temp, extract_dir=dir)# unzip and save

        os.remove(temp) # delete zip file

    return local_dir


# Helper function to store the passed in list in a .txt file inside ./txt directory.
def generateTXT(lst, sessionID):
    s = "Identified Libraries:\n\n"

    for lib in lst:
        s = s + lib + "\n"

    with open('txt\\' + sessionID + ".txt", 'wt') as out:
        print(s, file=out)

if __name__ == '__main__':
    app.run()